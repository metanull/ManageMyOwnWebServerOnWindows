<#
    .SYNOPSIS
        Create an empty Powershell Module

    .DESCRIPTION
        Create an empty Powershell Module with the following structure:
        - ModuleName
            - Build.psd1                    # Contains the module's configuration (automatically generated by New-Module)
            - Version.psd1                  # Contains the module's version (automatically generated during Build)
            - Build.ps1                     # A script that builds the module
            - Publish.ps1                   # A script that publishes the built module to a repository such as PSGallery
            - source                        # Contains the module's source code
                - public                    # Contains public/exposed functions
                    - Verb-Name.ps1         # Defines the public function "Verb-Name" (e.g.: "Get-Something")
                - private                   # Contains private functions (accessible only from within the module)
                    - Verb-Name.ps1         # Defines the private function "Verb-Name" (e.g.: "Invoke-Something")
                - init                      # Contains module initialization code
                    - Init.ps1              # Contains module initialization code, such as definition of Constants, etc.
                - class                     # Contains .net classes exposed by the module
                    - ClassName.cs          # Defines the class "ClassName"
            - test                          # Contains the module's tests
                - public                    # Contains tests for public/exposed functions
                    - Verb-Name.Tests.ps1   # Contains tests for the public function "Verb-Name" (e.g.: "Get-Something")
                - private                   # Contains tests for private functions
                    - Verb-Name.Tests.ps1   # Contains tests for the private function "Verb-Name" (e.g.: "Invoke-Something")
            - resource                      # Contains resources contained in the module (e.g. data files that are accessible to the module)
    
    .PARAMETER LiteralPath
        The path to the directory where the module will be created. E.g: $env:TEMP

    .PARAMETER Name
        The name of the module. E.g.: MyModule

    .PARAMETER Description
        The description of the module. E.g.: "A module that does something"

    .PARAMETER Uri
        The URI of the module's documentation or repository. E.g.: "https://www.test.com/mymodule" 

    .PARAMETER Author
        The author of the module. E.g.: "Pascal Havelange"

    .PARAMETER Vendor
        The vendor/company of the authors. E.g.: "MetaNull"

    .PARAMETER Copyright
        The copyright statement of the module. E.g.: "(c) 2025"

    .PARAMETER ModuleDependencies
        An array of module dependencies. E.g.: @("PackageManagement", "PowerShellGet")
        The module automatically adds the dependencies to the module's configuration file.

    .PARAMETER AssemblyDependencies
        An array of assembly dependencies. E.g.: @("System.Net.WebUtility", "System.Management.Automation.PSCredential")
        The module automatically adds the dependencies to the module's configuration file.

    .PARAMETER Force
        If the module directory already exists, overwrite it.

    .OUTPUTS
        Returns a [System.IO.FileInfo] object representing the module's configuration file (Build.psd1)

    .EXAMPLE
        # Create a new 'MyModule' module in the $env:TEMP directory
        $Module = New-Module -Path $env:TEMP -Name MyModule

        # Create a new public function 'Get-Something' in the module, and a test for it
        $Module | New-Function -Public -Verb Get -Name Something
        
        $Module | Invoke-Build
        $Module | Invoke-Publish

#>
[CmdletBinding()]
[OutputType([System.IO.FileInfo])]
param(
    [Parameter(Mandatory)]
    [ValidateScript({
        Test-Path -Path $_ -PathType Container
    })]
    [Alias('Path')]
    [string] $LiteralPath,

    [Parameter(Mandatory)]
    [ValidateScript({
        $_ -match '^[a-zA-Z][a-zA-Z0-9\._-]*$'
    })]
    [string] $Name,

    [Parameter(Mandatory = $false)]
    [AllowNull()]
    [AllowEmptyString()]
    [string] $Description = $null,

    [Parameter(Mandatory = $false)]
    [AllowNull()]
    [AllowEmptyString()]
    [ValidateScript({
        try {
            if($null -eq $_ -or [string]::empty -eq $_ -or [System.Uri]::new($_)) {
                return $true
            }
        } catch {
            # Swallow exception, to permit returninbg $false instead of throwing
        }
        return $false
    })]
    [string] $Uri = 'https://www.test.com/mymodule',

    [Parameter(Mandatory = $false)]
    [AllowNull()]
    [AllowEmptyString()]
    [string] $Author = ([System.Security.Principal.WindowsIdentity]::GetCurrent().Name),
    
    [Parameter(Mandatory = $false)]
    [AllowNull()]
    [AllowEmptyString()]
    [string] $Vendor = 'Unknown',
    
    [Parameter(Mandatory = $false)]
    [AllowNull()]
    [AllowEmptyString()]
    [string] $Copyright = "Â© $((Get-Date).Year). All rights reserved",
    
    [Parameter(Mandatory = $false)]
    [AllowNull()]
    [AllowEmptyCollection()]
    [string[]] $ModuleDependencies,
    
    [Parameter(Mandatory = $false)]
    [AllowNull()]
    [AllowEmptyCollection()]
    [string[]] $AssemblyDependencies,

    [Parameter(Mandatory = $false)]
    [switch] $Force

)
Process {
    $BackupErrorActionPreference = $ErrorActionPreference
    $ErrorActionPreference = 'Stop'
    try {
        $NewItemForce = $false
        $DirectoryPath = Join-Path $LiteralPath $Name
        if(Test-Path $DirectoryPath -PathType Any) {
            if($Force.IsPresent -and $Force) {
                "Target directory $DirectoryPath exists, overwriting." | Write-Warning
                $NewItemForce = $true
            } else {
                throw "Target directory $DirectoryPath exists"
            }
        }
        # Create the directories
        $RootDirectory = New-Item -Path $LiteralPath -Name $Name -ItemType Directory -Force:$NewItemForce
        $SourceDirectory = New-Item (Join-Path $RootDirectory source) -ItemType Directory -Force:$NewItemForce
        $TestDirectory = New-Item (Join-Path $RootDirectory test) -ItemType Directory -Force:$NewItemForce
        $SourcePublicDirectory = New-Item (Join-Path $SourceDirectory public) -ItemType Directory -Force:$NewItemForce
        $SourcePrivateDirectory = New-Item (Join-Path $SourceDirectory private) -ItemType Directory -Force:$NewItemForce
        $SourceInitDirectory = New-Item (Join-Path $SourceDirectory init) -ItemType Directory -Force:$NewItemForce
        $TestPublicDirectory = New-Item (Join-Path $TestDirectory public) -ItemType Directory -Force:$NewItemForce
        $TestPrivateDirectory = New-Item (Join-Path $TestDirectory private) -ItemType Directory -Force:$NewItemForce

        # Create the module's configuration file, script files, and module's sample source and test files
        if((Get-Variable INSIDE_MODULEMAKER_MODULE -ErrorAction SilentlyContinue)) {
            #INSIDE_MODULEMAKER_MODULE is a constant defined in the module
            #If it is set, then the script is run from a loaded module, PSScriptRoot = Directory of the psm1
            $ResourceDirectory = Get-Item (Join-Path $PSScriptRoot resource)
        } else {
            #Otherwise, the script was probably called from the command line, PSScriptRoot = Directory /source/private
            $ResourceDirectory = Get-Item (Join-Path (Split-Path (Split-Path $PSScriptRoot)) resource)
        }
        Copy-Item $ResourceDirectory\script\*.ps1 $RootDirectory -Force:$NewItemForce
        Copy-Item $ResourceDirectory\data\*.psd1 $RootDirectory -Force:$NewItemForce
        Copy-Item -Path $ResourceDirectory\dummy\* -Destination $RootDirectory -Recurse -Force:$NewItemForce

        # Update Module's configuration
        $ManifestFile = Get-Item (Join-Path $RootDirectory Build.psd1)
        $ManifestFileContent = Get-Content -LiteralPath $ManifestFile
        $Replace = @{
            '%%MODULE_GUID%%'= (New-Guid)
            '%%MODULE_NAME%%' = "$Name"
            '%%MODULE_DESCRIPTION%%' = "$Description"
            '%%MODULE_URI%%' = "$Uri"
            '%%MODULE_AUTHOR%%' = "$Author"
            '%%MODULE_VENDOR%%'= "$Vendor"
            '%%MODULE_COPYRIGHT%%' = "$Copyright"
            "%%ASSEMBLY_DEPENDENCIES%%" = $null
            "%%MODULE_DEPENDENCIES%%" = $null
        }
        if($AssemblyDependencies) {
            $Replace.'%%ASSEMBLY_DEPENDENCIES%%' = "'$($AssemblyDependencies -join "','")'"
        }
        if($ModuleDependencies) {
            $Replace.'"%%MODULE_DEPENDENCIES%%"' = "'$($ModuleDependencies -join "','")'"
        }
        $Replace.GetEnumerator() | Foreach-Object {
            if($_.Value) {
                $ManifestFileContent = $ManifestFileContent -replace "$($_.Key)","$($_.Value)"
            } else {
                $ManifestFileContent = $ManifestFileContent -replace "$($_.Key)"
            }
        }
        $ManifestFileContent | Set-Content -LiteralPath $ManifestFile -Force:$NewItemForce

        $ManifestFile | Write-Output
    } finally {
        $ErrorActionPreference = $BackupErrorActionPreference
    }
}